
For what concerns synchronous communications, it is actually possible to consider different synchronous models.
There is an extensive literature on process algebras (eg CCS, pi-calculus, ACP, etc.) where the symmetry between sender and receiver in synchronous communications is assumed when resolving choices. In such models, no essential distinction is made between server and receiver,  so leading to situations where a receiver can force a specific choice on a sender, as happens also in  \cite{BLT20b}.
In a blocking message exchange however, the sender and receiver can have different roles during the communication and this reflects to other aspects of the model, in particular internal and external choices. This distinction is obviously fundamental for asynchronous communication but, in many cases, this distinction is also kept for synchronous communication, as done, for instance in \cite{aey03}.
 In this synchronous model,  communication means the sender chooses to send a message and gets blocked until the message is received. However, the send/choice is already fixed by the time the receive happens\footnote{We thank an anonimous referee of another paper for implicitly suggesting
 us to complete the investigation on the \quo{preservation of communication-properties by composition}
by taking into account also  asymmetric synchronous interactions.}.

We can consider the following simple system for (finite) communicating processes in the style of MPST
as a formalism for describing 
examples for the two above possible synchronous communications. 

 Let $P$ range over the terms of the following grammar:
  \begin{align*}
	 \begin{array}{lll@{\qquad\qquad}lll}
		P   &   ::=  & \mathbf{0}\   \mid\  \q!\Set{\al_1:P_1\ldots \al_n:P_n }
		\ \mid\  \q?\Set{\al_1:P_1\ldots \al_n:P_n }
	 \end{array}
  \end{align*}
  where the  $\ll_i$ are pairwise distinct messages. A term $P$ denotes a process.
  %
 
   A term $\mathcal{M}$ generated by the grammar
	 \begin{align*}
	 \mathcal{M}  ::={\p}\triangleright  P\ \mid\  \mathcal{M} \mid \mathcal{M}
	 \end{align*}
  is a \emph{system of named processes}
  
As discussed previously, two synchronous operational semantics are possible, that we shall dub
{\em symmetric} and {\em asymmetric}. For our simple calculus they are naturally as follows.


\noindent
{\sf Symmetric-sinchronous operational semantics}
$$
\begin{array}{r}
\mathcal{M} \mid {\p}\triangleright  \text{\bf !}\Set{\q:\msg.P}{\cup}\Set{\q_i:\msg_i.P'_i}_{i\in I}
\mid {\q}\triangleright \text{\bf ?}\Set{\p:\msg.Q}{\cup}\Set{\msg_j:\al_j.Q'_j}_{j\in J}  
\\[2mm]
\arro{\gint[][A][m][B]} \
\mathcal{M} \mid {\p}\triangleright  P \mid  {\q}\triangleright Q 
\end{array}
$$
\vspace{4mm}
\noindent
{\sf Asymmetric-sinchronous operational semantics}
$$
\begin{array}{rcl}
\mathcal{M} \mid {\p}\triangleright  \text{\bf !}\Set{\q:\al.P}{\cup}\Set{\q_i:\al_i.P'_i}_{i\in I}
& \arro{\aout} &
\mathcal{M} \mid {\p}\triangleright  \q\text{\bf !}[\msg].P
\\[2mm]
\mathcal{M} \mid {\p}\triangleright   \q\text{\bf !}[\msg.P] \mid 
{\q}\triangleright ?\Set{\p:\al.Q}{\cup}\Set{\p_j:\al_j.Q'_j}_{j\in J}  
& \arro{\ain} &
\mathcal{M} \mid {\p}\triangleright  P \mid  {\q}\triangleright Q 
\end{array}
$$

It is not difficult to check that the two semantics are non equivalent, since it is enough to have a 
simple system where a participant has an input (or output) capability which is not matched
in the sender (or receiver).
$$
{\p}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg[n].\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
$$
By the symmetric semantics the only reduction sequence is
$$
{\p}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg[n].\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\arro{\gint[][A][m][B]}
\mathbf{0} \mid \mathbf{0}
$$
whereas, in the asymmetric one the system can get stuck even if some process has not completed (i.e. reduced to $\mathbf{0}$)

$$
{\p}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg[n].\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\arro{\aout[A][B][][n]}
{\p}\triangleright  \ptp[B]\text{\bf !}[\msg[n]].\mathbf{0}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\not\!\longrightarrow
$$

In order to compare the two semantics some natural relation has to be formalised,
making equivalent sequences like $\gint[][A][m][B]\cat\gint[][C][n][D]$
and $\aout\cat\ain\cat\aout[C][D][][n]\cat\ain[C][D][][n]$.
As well as $\aout\cat\ain\cat\aout[C][D][][n]\cat\ain[C][D][][n]$ and $\aout\cat\aout[C][D][][n]\cat\ain\cat\ain[C][D][][n]$.


The different behaviours in the above example depends immediately on the fact that a participant
possesses an output action and no participants contains the corresponding input.

This problem never arise if, as in many choreographic approaches to the development of concurrent systems (MPTSs, for instance), the latter
are obtained by means of a projection operation on choreogreaphies, as done in MPSTs.
A global type formalism for our example can be

$$\mathsf{G} ::= \mathbf{end} \mid  \bigvee_{i\in I}\Set{\p_i\rightarrow\q_i{:}\msg[m]_i.\mathsf{G}_i}$$

In any MPST setting (any choreographic setting as a matter of facts) the least property
expected is that a system obtained by projection do behave as described by the global type.
It is then reasonable to restrict our investigation to global descriptions whose
projected system - with the symmetric semantics -  behaves as the global description prescribes.
For instance, Let us consider the following global type.
$$
\mathbf{G} = \bigvee\Set{\p\rightarrow\ptp[D]{:}\msg[m].\ptp[C]\rightarrow\ptp[B]{:}\msg[m].\mathbf{end},\,
                                         \p\rightarrow\ptp[B]{:}\msg[m].\mathbf{end},\,
                                         \ptp[C]\rightarrow\ptp[B]{:}\msg[m].\p\rightarrow\ptp[D]{:}\msg[m].\mathbf{end}}
$$

The system obtained by projection is


$$
\proj{\mathbf{G}}{} = {\p}\triangleright  \text{\bf !}\Set{\ptp[D]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg.\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[C]{:}\msg.\mathbf{0},\, \ptp[A]{:}\msg.\mathbf{0}}
\mid
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
$$

with the symmetric semantics, 
the only possible reduction sequences are
$$
\proj{\mathbf{G}}{} \arro{\gint[][A][m][D]}
{\q}\triangleright  \text{\bf ?}\Set{\ptp[C]{:}\msg.\mathbf{0},\, \ptp[A]{:}\msg.\mathbf{0}}
\mid
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\arro{\gint[][C][m][B]}
\mathbf{0}
$$
or
$$
\proj{\mathbf{G}}{} 
\arro{\gint[][C][m][B]}
{\p}\triangleright  \text{\bf !}\Set{\ptp[D]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\arro{\gint[][A][m][D]}
\mathbf{0}
$$
or
$$
\proj{\mathbf{G}}{} \arro{\gint[][A][m][B]}
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\not\longrightarrow
$$

That is, exactly as described by $\mathbf{G}$.
Such a property, is usually obtained in MPTSs formalisms by means of strong restrictions
on the syntax (forcing the same sender in the first interactions in a disjunction)
and requirements on the processes obtained by projection.
In our example the htwo syntax differ on  $\proj{\mathbf{G}}{}$.


As a matter of fact 
{\small
$$
\begin{array}{rcl}
\proj{\mathbf{G}}{} 
           & \arro{\aout[A][B][][m]} &
{\p}\triangleright  \q\text{\bf !}[\msg].\mathbf{0}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[C]{:}\msg.\mathbf{0},\, \ptp[A]{:}\msg.\mathbf{0}}
\mid
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}\\
      &   \arro{\ain[A][B][][m]}&
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}\\
      &   \arro{\aout[C][B][][m]} &
{\ptp[C]}\triangleright  \ptp[B]\text{\bf !}[\msg].\mathbf{0}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}\\
   &\not\!\!\longrightarrow &
\end{array}
$$
}

In our simplified setting, our investigation could be worded as:
Is it possible to characterise (symmetrically) correct and complete global types 
such that on their projections the two semantics are (modulo some equivalence of the sort
mentioned before) equivalent?
This problem is can be also rephrased as: is it possible to characterise
(asymmetrically) correct and complete global types?
A really general solution, however, should not work on the choreographic model of MPTSs only.
We shall then consider the choreographic framework of FCL.
























Choreographic models of message-passing systems are gaining momentum
both in academia~\cite{BasuB11,BravettiZ07,CarboneHY12} and
industry~\cite{WS-CDL,BPMN,boner18}.
% 
These models envisage the so-called \emph{global} and \emph{local}
views of communicating systems.
%
The former can be thought of as holistic descriptions of protocols
that a number of participants should realise through some
communication actions.
%

We propose \emph{formal choreography languages} (FCL) as a general
framework to formalise message-passing systems; existing choreographic
models can be conceived as specifications of FCLs.
% 
Specifically, we introduce \emph{global} and \emph{local} languages.
%
Global languages (g-languages for short) are made of words built out
of \emph{interactions} of the form $\gint[]$, representing the fact
that participant \p\ sends message $\msg$ to participant \q, and
participant \q\ receives it.
%
Local languages (l-languages for short) consist of words of
\emph{actions} of the forms $\ain$ and $\aout$,
respectively representing that participant \q\ receives message
$\msg$ from \p\ and that participant \p\ sends message $\msg$ to \q.

Abstractly such languages consist of runs of a system described in
terms of sequences of interactions at the global level and executed
through message-passing at the local level.
%
A word $\acword$ in a global language represents then a possible run
expected of a communicating system % $\aCS$
% .
%
% For instance, we can model a continuation of $\acword$ as another word
% $\acword'$ such that $\acword \cat \acword'$ is also in the language.
%
% Also, $\acword$ induces
inducing an expected \quo{local} behaviour on each
participant $\p$: the projection of $\acword$ on $\p$ %, written $\proj{\acword}{\p}$,
yields the sequence of \emph{output} or
\emph{input} actions performed by \p\ along the run $\acword$.

We strive for generality; basically \emph{prefix-closure} is the
only requirement we impose on our choreography languages.
%
The gist is that, if a sequence of interactions or of communications
is an observable behaviour of a system, any prefix of the sequence
should be observable as well.
%
(We discuss some implications of relaxing prefix-closure in
\cref{sec:conc}.)
%
This allows us to consider partial executions as well as
\quo{complete} ones.
%%% The latter can be formalised in terms of \quo{maximal words} (namely words without continuations).
%
We admit infinite words to account for diverging computations,
ubiquitous in communication protocols.

Some g-languages cannot be faithfully executed by distributed
components; consider $\Set{\gint, \ \gint \cat \gint[][c][n][d]}$ that
specifies a system where, if occurring, the interaction between \p[c]
and \p[d] has to follow the one between \p\ and \q.
%
Clearly, this is not possible if the participants act concurrently
because \p[c] and \p[d] are not aware of when the interaction between
\p\ and \q\ takes place.
%%% Notice that this problem remains also when restricting to maximal words.

\noindent\textbf{Contributions \& structure}\
We summarise below our main contributions.
%
(Proofs and further material are in the appendixes.)

\cref{sec:c-lang} introduces FCL (g-languages in \cref{def:chorlang},
l-languages in \cref{def:actlang}) and adapts standard constructions from
the literature.
%
In particular, we render communicating systems as sets of l-languages
(\cref{def:commSyst}) whose semantics is inspired by~\cite{bz83},
while we borrow projections from choreographies and multi-party
session types.

\cref{sec:ui} considers correctness and completeness in FCLs.
%
An immediate consequence of our constructions is the completeness of
systems projected from g-languages (\cref{th:completeness}).
%
Correctness is more tricky; for it, \cref{def:closedness} introduces
\emph{closure under unknown information} (CUI).
%
  Intuitively, a g-language is CUI if it contains extensions of words with a single interaction whose participants cannot distinguish the extended word from other (possibly different) words of the language.
% 
\cref{th:correctness} characterises correctness of projected systems
in terms of CUI.

\cref{sec:prop} shows how FCLs capture many relevant communication
properties in a fairly uniform way.
%

\cref{sec:proj-prop} proposes \emph{branch-awareness} (\cref{def:ba})
to ensure the communication properties defined in \cref{sec:prop} (\cref{thm:baconseq}).
%
Intuitively, branch-awareness requires each participant to
\quo{distinguish} words where its behaviour differs.
%
Notably, we separate the conditions for correctness from the ones for communication properties. Most approaches in the literature instead combine them into a single condition, which takes names such as well-branchedness or projectability~\cite{hlvlcmmprttz16}.
Thus, these single conditions are stronger than each of CUI and branch-awareness.
%

\cref{sec:mpst,sec:chor-automata} illustrate the generality of FCLs on
two case studies, respectively taken from multiparty session types~\cite{SeveriD19} and
choreography automata~\cite{blt20}.

\cref{sec:conc} draws some conclusions and discusses future work.

We remark that FCL can capture protocols that cannot be represented by
regular g-languages such as the \quo{task dispatching} protocol in
\cref{ex:parenthesis}.
%
To the best of our knowledge this kind of protocols cannot be formalised in other approaches.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% TeX-master: "main"
%%% End:
