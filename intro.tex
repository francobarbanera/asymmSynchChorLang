
For what concerns synchronous communications, it is actually possible to consider different synchronous models.
There is an extensive literature on process algebras (eg CCS, pi-calculus, ACP, etc.) where the symmetry between sender and receiver in synchronous communications is assumed when resolving choices. In such models, no essential distinction is made between server and receiver,  so leading to situations where a receiver can force a specific choice on a sender, as happens also in  \cite{BLT20b}.
In a blocking message exchange however, the sender and receiver can have different roles during the communication and this reflects to other aspects of the model, in particular internal and external choices. This distinction is obviously fundamental for asynchronous communication but, in many cases, this distinction is also kept for synchronous communication, as done, for instance in \cite{aey03}.
 In this synchronous model,  communication means the sender chooses to send a message and gets blocked until the message is received. However, the send/choice is already fixed by the time the receive happens\footnote{We thank an anonimous referee of another paper for implicitly suggesting
 us to complete the investigation on the \quo{preservation of communication-properties by composition}
by taking into account also  asymmetric synchronous interactions.}.

We can consider the following simple system for (finite) communicating processes in the style of MPST
as a formalism for describing 
examples for the two above possible synchronous communications. 

 Let $P$ range over the terms of the following grammar:
  \begin{align*}
	 \begin{array}{lll@{\qquad\qquad}lll}
		P   &   ::=  & \mathbf{0}\   \mid\  \q!\Set{\al_1:P_1\ldots \al_n:P_n }
		\ \mid\  \q?\Set{\al_1:P_1\ldots \al_n:P_n }
	 \end{array}
  \end{align*}
  where the  $\ll_i$ are pairwise distinct messages. A term $P$ denotes a process.
  %
 
   A term $\mathcal{M}$ generated by the grammar
	 \begin{align*}
	 \mathcal{M}  ::={\p}\triangleright  P\ \mid\  \mathcal{M} \mid \mathcal{M}
	 \end{align*}
  is a \emph{system of named processes}
  
As discussed previously, two synchronous operational semantics are possible, that we shall dub
{\em symmetric} and {\em asymmetric}. For our simple calculus they are naturally as follows.


\noindent
{\sf Symmetric-sinchronous operational semantics}
$$
\begin{array}{r}
\mathcal{M} \mid {\p}\triangleright  \text{\bf !}\Set{\q:\msg.P}{\cup}\Set{\q_i:\msg_i.P'_i}_{i\in I}
\mid {\q}\triangleright \text{\bf ?}\Set{\p:\msg.Q}{\cup}\Set{\msg_j:\al_j.Q'_j}_{j\in J}  
\\[2mm]
\arro{\gint[][A][m][B]} \
\mathcal{M} \mid {\p}\triangleright  P \mid  {\q}\triangleright Q 
\end{array}
$$
\vspace{4mm}
\noindent
{\sf Asymmetric-sinchronous operational semantics}
$$
\begin{array}{rcl}
\mathcal{M} \mid {\p}\triangleright  \text{\bf !}\Set{\q:\al.P}{\cup}\Set{\q_i:\al_i.P'_i}_{i\in I}
& \arro{\aout} &
\mathcal{M} \mid {\p}\triangleright  \q\text{\bf !}[\msg.P]
\\[2mm]
\mathcal{M} \mid {\p}\triangleright   \q\text{\bf !}[\msg.P] \mid 
{\q}\triangleright ?\Set{\p:\al.Q}{\cup}\Set{\p_j:\al_j.Q'_j}_{j\in J}  
& \arro{\ain} &
\mathcal{M} \mid {\p}\triangleright  P \mid  {\q}\triangleright Q 
\end{array}
$$

It is not difficult to check that the two semantics are non equivalent, since it is enough to have a 
simple system where a participant has an input (or output) capability which is not matched
in the sender (or receiver).
$$
{\p}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg[n].\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
$$
By the symmetric semantics the only reduction sequence is
$$
{\p}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg[n].\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\arro{\gint[][A][m][B]}
\mathbf{0} \mid \mathbf{0}
$$
whereas, in the asymmetric one the system can get stuck even if some process has not completed (i.e. reduced to $\mathbf{0}$

$$
{\p}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg[n].\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\arro{\aout[A][B][][n]}
{\p}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg[n].\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\not\!\longrightarrow
$$



$$
\aCS = {\p}\triangleright  \text{\bf !}\Set{\ptp[D]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg.\mathbf{0}}
\mid 
{\q}\triangleright  \text{\bf ?}\Set{\ptp[C]{:}\msg.\mathbf{0},\, \ptp[A]{:}\msg.\mathbf{0}}
\mid
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
$$

with the symmetric semantics, 
the only possible reduction sequences are
$$
\aCS \longrightarrow
{\q}\triangleright  \text{\bf ?}\Set{\ptp[C]{:}\msg.\mathbf{0},\, \ptp[A]{:}\msg.\mathbf{0}}
\mid
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\longrightarrow
\mathbf{0}
$$
or
$$
\aCS \longrightarrow
{\p}\triangleright  \text{\bf !}\Set{\ptp[D]{:}\msg.\mathbf{0},\, \ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\longrightarrow
\mathbf{0}
$$
or
$$
\aCS \longrightarrow
{\ptp[C]}\triangleright  \text{\bf !}\Set{\ptp[B]{:}\msg.\mathbf{0}}
\mid
{\ptp[D]}\triangleright  \text{\bf ?}\Set{\ptp[A]{:}\msg.\mathbf{0}}
\not\longrightarrow
$$



The natural question to ask is characte


























Choreographic models of message-passing systems are gaining momentum
both in academia~\cite{BasuB11,BravettiZ07,CarboneHY12} and
industry~\cite{WS-CDL,BPMN,boner18}.
% 
These models envisage the so-called \emph{global} and \emph{local}
views of communicating systems.
%
The former can be thought of as holistic descriptions of protocols
that a number of participants should realise through some
communication actions.
%

We propose \emph{formal choreography languages} (FCL) as a general
framework to formalise message-passing systems; existing choreographic
models can be conceived as specifications of FCLs.
% 
Specifically, we introduce \emph{global} and \emph{local} languages.
%
Global languages (g-languages for short) are made of words built out
of \emph{interactions} of the form $\gint[]$, representing the fact
that participant \p\ sends message $\msg$ to participant \q, and
participant \q\ receives it.
%
Local languages (l-languages for short) consist of words of
\emph{actions} of the forms $\ain$ and $\aout$,
respectively representing that participant \q\ receives message
$\msg$ from \p\ and that participant \p\ sends message $\msg$ to \q.

Abstractly such languages consist of runs of a system described in
terms of sequences of interactions at the global level and executed
through message-passing at the local level.
%
A word $\acword$ in a global language represents then a possible run
expected of a communicating system % $\aCS$
% .
%
% For instance, we can model a continuation of $\acword$ as another word
% $\acword'$ such that $\acword \cat \acword'$ is also in the language.
%
% Also, $\acword$ induces
inducing an expected \quo{local} behaviour on each
participant $\p$: the projection of $\acword$ on $\p$ %, written $\proj{\acword}{\p}$,
yields the sequence of \emph{output} or
\emph{input} actions performed by \p\ along the run $\acword$.

We strive for generality; basically \emph{prefix-closure} is the
only requirement we impose on our choreography languages.
%
The gist is that, if a sequence of interactions or of communications
is an observable behaviour of a system, any prefix of the sequence
should be observable as well.
%
(We discuss some implications of relaxing prefix-closure in
\cref{sec:conc}.)
%
This allows us to consider partial executions as well as
\quo{complete} ones.
%%% The latter can be formalised in terms of \quo{maximal words} (namely words without continuations).
%
We admit infinite words to account for diverging computations,
ubiquitous in communication protocols.

Some g-languages cannot be faithfully executed by distributed
components; consider $\Set{\gint, \ \gint \cat \gint[][c][n][d]}$ that
specifies a system where, if occurring, the interaction between \p[c]
and \p[d] has to follow the one between \p\ and \q.
%
Clearly, this is not possible if the participants act concurrently
because \p[c] and \p[d] are not aware of when the interaction between
\p\ and \q\ takes place.
%%% Notice that this problem remains also when restricting to maximal words.

\noindent\textbf{Contributions \& structure}\
We summarise below our main contributions.
%
(Proofs and further material are in the appendixes.)

\cref{sec:c-lang} introduces FCL (g-languages in \cref{def:chorlang},
l-languages in \cref{def:actlang}) and adapts standard constructions from
the literature.
%
In particular, we render communicating systems as sets of l-languages
(\cref{def:commSyst}) whose semantics is inspired by~\cite{bz83},
while we borrow projections from choreographies and multi-party
session types.

\cref{sec:ui} considers correctness and completeness in FCLs.
%
An immediate consequence of our constructions is the completeness of
systems projected from g-languages (\cref{th:completeness}).
%
Correctness is more tricky; for it, \cref{def:closedness} introduces
\emph{closure under unknown information} (CUI).
%
  Intuitively, a g-language is CUI if it contains extensions of words with a single interaction whose participants cannot distinguish the extended word from other (possibly different) words of the language.
% 
\cref{th:correctness} characterises correctness of projected systems
in terms of CUI.

\cref{sec:prop} shows how FCLs capture many relevant communication
properties in a fairly uniform way.
%

\cref{sec:proj-prop} proposes \emph{branch-awareness} (\cref{def:ba})
to ensure the communication properties defined in \cref{sec:prop} (\cref{thm:baconseq}).
%
Intuitively, branch-awareness requires each participant to
\quo{distinguish} words where its behaviour differs.
%
Notably, we separate the conditions for correctness from the ones for communication properties. Most approaches in the literature instead combine them into a single condition, which takes names such as well-branchedness or projectability~\cite{hlvlcmmprttz16}.
Thus, these single conditions are stronger than each of CUI and branch-awareness.
%

\cref{sec:mpst,sec:chor-automata} illustrate the generality of FCLs on
two case studies, respectively taken from multiparty session types~\cite{SeveriD19} and
choreography automata~\cite{blt20}.

\cref{sec:conc} draws some conclusions and discusses future work.

We remark that FCL can capture protocols that cannot be represented by
regular g-languages such as the \quo{task dispatching} protocol in
\cref{ex:parenthesis}.
%
To the best of our knowledge this kind of protocols cannot be formalised in other approaches.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% TeX-master: "main"
%%% End:
